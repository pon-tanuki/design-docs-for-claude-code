# ADR-001: [決定事項のタイトル]

## ステータス

[Proposed | Accepted | Deprecated | Superseded]

## コンテキスト

[この決定が必要となった背景や状況を説明]

## 決定事項

[何を決定したか、どのような選択をしたかを明確に記述]

## 検討した選択肢

### 選択肢1: [選択肢名]

**説明**:
[この選択肢の詳細]

**メリット**:
- [メリット1]
- [メリット2]

**デメリット**:
- [デメリット1]
- [デメリット2]

### 選択肢2: [選択肢名]

**説明**:
[この選択肢の詳細]

**メリット**:
- [メリット1]
- [メリット2]

**デメリット**:
- [デメリット1]
- [デメリット2]

### 選択肢3: [選択肢名]

[同様に記述]

## 決定理由

[なぜその選択肢を選んだか、判断基準は何だったか]

1. **理由1**: [説明]
2. **理由2**: [説明]
3. **理由3**: [説明]

## 影響

**ポジティブ**:
- [プラスの影響1]
- [プラスの影響2]

**ネガティブ**:
- [マイナスの影響1]
- [マイナスの影響2]

**リスク**:
- [リスク1]: [軽減策]
- [リスク2]: [軽減策]

## 実装ノート

[実装時の注意事項や考慮事項]

## 関連するADR

- [ADR-XXX](./ADR-XXX.md): [関連する決定]

## 参考資料

- [参考URL1](https://example.com)
- [参考URL2](https://example.com)

## メタデータ

- **決定日**: YYYY-MM-DD
- **決定者**: [名前]
- **レビュアー**: [名前1, 名前2]

---

# 実際の例

以下、実際のADRの例をいくつか示します。

---

# ADR-001: フロントエンドフレームワークの選定

## ステータス

Accepted

## コンテキスト

新しいWebアプリケーションを開発するにあたり、フロントエンドフレームワークを選定する必要があります。
小規模チームでの開発であり、開発スピードと保守性を重視したい。

## 決定事項

Next.js (React) を採用する

## 検討した選択肢

### 選択肢1: Next.js (React)

**説明**:
Reactベースのフルスタックフレームワーク。SSR/SSGに対応。

**メリット**:
- SEOに有利 (SSR対応)
- TypeScriptとの親和性が高い
- 豊富なエコシステム
- Vercelでの簡単なデプロイ
- App Routerによる最新のアーキテクチャ

**デメリット**:
- 学習曲線がやや急
- バンドルサイズが大きくなりがち

### 選択肢2: Vue.js (Nuxt.js)

**説明**:
Vue.jsベースのフレームワーク。学習コストが低い。

**メリット**:
- 学習が容易
- 公式ドキュメントが充実
- シンプルな構文

**デメリット**:
- Reactに比べてエコシステムが小さい
- 求人市場でのReactの優位性

### 選択肢3: Vanilla JavaScript + Vite

**説明**:
フレームワークを使わず、モダンなビルドツールで開発。

**メリット**:
- 軽量
- フレームワークへの依存がない

**デメリット**:
- 開発効率が低い
- 車輪の再発明になる

## 決定理由

1. **エコシステムの充実**: Reactエコシステムは非常に大きく、ほとんどのユースケースに対応したライブラリが存在する
2. **採用実績**: 多くの企業で採用されており、情報が豊富
3. **SEO対応**: SSRによるSEO最適化が容易
4. **TypeScript対応**: 型安全な開発が可能
5. **デプロイの容易さ**: Vercelでワンクリックデプロイ可能

## 影響

**ポジティブ**:
- 開発スピードの向上
- 高品質なUIコンポーネントの利用
- SEOパフォーマンスの向上

**ネガティブ**:
- 初期学習コスト
- バンドルサイズの増加

**リスク**:
- フレームワークのアップデートに追従する必要がある
  - 軽減策: LTS版を使用し、慎重にアップデート

## 実装ノート

- App Routerを使用 (Pages Routerではない)
- TypeScriptを必須とする
- ESLintとPrettierで品質を担保

## 関連するADR

- [ADR-002](./ADR-002.md): 状態管理ライブラリの選定

## 参考資料

- [Next.js Documentation](https://nextjs.org/docs)
- [React Documentation](https://react.dev/)

## メタデータ

- **決定日**: 2024-01-01
- **決定者**: 開発チーム
- **レビュアー**: テックリード

---

# ADR-002: 状態管理ライブラリの選定

## ステータス

Accepted

## コンテキスト

アプリケーションが複雑になり、グローバルな状態管理が必要になってきました。
小規模プロジェクトのため、シンプルで学習コストの低いソリューションが望ましい。

## 決定事項

Zustand を採用する

## 検討した選択肢

### 選択肢1: Zustand

**説明**:
軽量でシンプルな状態管理ライブラリ

**メリット**:
- 非常にシンプルなAPI
- ボイラープレートが少ない
- TypeScriptとの親和性が高い
- バンドルサイズが小さい (1KB)
- React Hooks と自然に統合

**デメリット**:
- Reduxに比べてエコシステムが小さい
- DevToolsの機能がReduxより限定的

### 選択肢2: Redux Toolkit

**説明**:
Redux の公式な推奨ツール

**メリット**:
- 業界標準
- 強力なDevTools
- 大規模アプリに適している
- 豊富なエコシステム

**デメリット**:
- 学習コストが高い
- ボイラープレートが多い
- 小規模プロジェクトにはオーバースペック

### 選択肢3: React Context API

**説明**:
React標準の状態管理

**メリット**:
- 追加ライブラリ不要
- React公式

**デメリット**:
- パフォーマンス問題が発生しやすい
- 複雑な状態管理には不向き

## 決定理由

1. **シンプルさ**: 小規模プロジェクトに適したシンプルなAPI
2. **学習コスト**: チーム全員が短時間で習得可能
3. **パフォーマンス**: 不要な再レンダリングを防ぐ
4. **TypeScript対応**: 型推論が優れている
5. **バンドルサイズ**: 軽量で高速

## 影響

**ポジティブ**:
- 開発速度の向上
- コードの可読性向上
- パフォーマンスの改善

**ネガティブ**:
- Redux経験者には慣れが必要

**リスク**:
- 将来的に大規模化した場合の移行コスト
  - 軽減策: ストアの設計を適切に行う

## 実装ノート

```typescript
// 使用例
import { create } from 'zustand';

interface UserState {
  user: User | null;
  setUser: (user: User) => void;
}

const useUserStore = create<UserState>((set) => ({
  user: null,
  setUser: (user) => set({ user })
}));
```

## 関連するADR

- [ADR-001](./ADR-001.md): フロントエンドフレームワークの選定

## 参考資料

- [Zustand Documentation](https://github.com/pmndrs/zustand)

## メタデータ

- **決定日**: 2024-01-05
- **決定者**: 開発チーム
- **レビュアー**: テックリード

---

# ADR-003: データベースの選定

## ステータス

Accepted

## コンテキスト

アプリケーションのデータ永続化のため、データベースを選定する必要があります。
リレーショナルデータが主で、トランザクション処理が必要です。

## 決定事項

PostgreSQL を採用する

## 検討した選択肢

### 選択肢1: PostgreSQL

**説明**:
オープンソースのリレーショナルデータベース

**メリット**:
- 高機能 (JSON型、全文検索など)
- ACIDトランザクション対応
- 豊富なドキュメント
- Supabaseで簡単にホスティング可能
- 無料枠が充実

**デメリット**:
- MySQLに比べてやや複雑

### 選択肢2: MySQL

**説明**:
広く使われているリレーショナルデータベース

**メリット**:
- シンプル
- 広く採用されている
- 情報が豊富

**デメリット**:
- PostgreSQLに比べて機能が少ない
- JSON型のサポートが弱い

### 選択肢3: MongoDB

**説明**:
NoSQLドキュメントデータベース

**メリット**:
- スキーマレス
- スケーラビリティ

**デメリット**:
- リレーショナルデータに不向き
- トランザクション処理が弱い

## 決定理由

1. **機能性**: JSON型、配列型などの高度な機能
2. **トランザクション**: 堅牢なACIDトランザクション
3. **ホスティング**: Supabaseで簡単にホスティング
4. **コスト**: 無料枠が充実
5. **Prismaとの相性**: ORMとの統合が良好

## 影響

**ポジティブ**:
- データの整合性確保
- 高度なクエリが可能
- フリー枠での運用が可能

**ネガティブ**:
- MySQL経験者には学習コストがある

**リスク**:
- データベース移行の困難さ
  - 軽減策: ORMを使用し、DBに依存しないコードを書く

## 実装ノート

- Prisma ORMを使用
- マイグレーションファイルでスキーマ管理
- 本番環境はSupabaseを使用

## 関連するADR

なし

## 参考資料

- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Supabase](https://supabase.com/)

## メタデータ

- **決定日**: 2024-01-01
- **決定者**: 開発チーム
- **レビュアー**: テックリード
